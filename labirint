import tkinter as tk
from tkinter import messagebox
import random

class MazeGame:
    def __init__(self, root, cols=21, rows=15, cell_size=30,
                 time_limit_sec=40, num_exits=3):
        self.root = root
        self.root.title("üï∑Ô∏è –ü–∞—É–∫ –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–µ")
        self.root.configure(bg="#e8f4f8")

        self.cols = cols if cols % 2 == 1 else cols + 1
        self.rows = rows if rows % 2 == 1 else rows + 1
        self.cell_size = cell_size
        self.time_limit = time_limit_sec
        self.num_exits = num_exits

        title_label = tk.Label(root,
                               text=f"üï∑Ô∏è –ü–ê–£–ö –í –õ–ê–ë–ò–†–ò–ù–¢–ï ({num_exits} –≤—ã—Ö–æ–¥–∞)",
                               font=("Arial", 16, "bold"),
                               bg="#e8f4f8", fg="#2c3e50")
        title_label.pack(pady=(10, 5))

        self.canvas = tk.Canvas(root, width=self.cols * self.cell_size,
                                height=self.rows * self.cell_size,
                                bg="#f8f9fa", highlightthickness=2,
                                highlightbackground="#3498db")
        self.canvas.pack(pady=10)

        control_frame = tk.Frame(root, bg="#e8f4f8")
        control_frame.pack()

        tk.Label(control_frame, text="–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã—Ö–æ–¥–æ–≤:",
                 bg="#e8f4f8", font=("Arial", 10)).pack(side=tk.LEFT, padx=(0, 5))

        self.exit_var = tk.StringVar(value=str(num_exits))
        exit_spinbox = tk.Spinbox(control_frame, from_=1, to=10,
                                  width=5, textvariable=self.exit_var,
                                  font=("Arial", 10))
        exit_spinbox.pack(side=tk.LEFT, padx=5)

        tk.Button(control_frame, text="–ü—Ä–∏–º–µ–Ω–∏—Ç—å", command=self.update_exits,
                  bg="#9b59b6", fg="white", font=("Arial", 9),
                  padx=10, pady=2).pack(side=tk.LEFT, padx=5)

        btn_frame = tk.Frame(root, bg="#e8f4f8")
        btn_frame.pack(pady=5)

        tk.Button(btn_frame, text="üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞", command=self.reset_game,
                  bg="#3498db", fg="white", font=("Arial", 10, "bold"),
                  padx=10, pady=5).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞—É–∫–∞", command=self.start_dfs,
                  bg="#2ecc71", fg="white", font=("Arial", 10, "bold"),
                  padx=10, pady=5).pack(side=tk.LEFT, padx=5)

        self.timer_label = tk.Label(root, text="‚è±Ô∏è –í—Ä–µ–º—è: -- —Å",
                                    font=("Arial", 12, "bold"),
                                    bg="#e8f4f8", fg="#e74c3c")
        self.timer_label.pack()

        info_label = tk.Label(root,
                              text=f"–ü–∞—É–∫ –∏—â–µ—Ç –ª—é–±–æ–π –∏–∑ {num_exits} –≤—ã—Ö–æ–¥–æ–≤ (DFS –∞–ª–≥–æ—Ä–∏—Ç–º)",
                              font=("Arial", 9), bg="#e8f4f8", fg="#7f8c8d")
        info_label.pack(pady=(5, 10))

        self.reset_game()

    def update_exits(self):
        try:
            new_num = int(self.exit_var.get())
            if 1 <= new_num <= 10:
                self.num_exits = new_num
                self.reset_game()
                info_label = self.root.winfo_children()[-1]
                info_label.config(text=f"–ü–∞—É–∫ –∏—â–µ—Ç –ª—é–±–æ–π –∏–∑ {new_num} –≤—ã—Ö–æ–¥–æ–≤ (DFS –∞–ª–≥–æ—Ä–∏—Ç–º)")
                title_label = self.root.winfo_children()[0]
                title_label.config(text=f"üï∑Ô∏è –ü–ê–£–ö –í –õ–ê–ë–ò–†–ò–ù–¢–ï ({new_num} –≤—ã—Ö–æ–¥–∞)")
            else:
                messagebox.showwarning("–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 10")
        except ValueError:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")

    def reset_game(self):
        if hasattr(self, 'moving') and self.moving:
            return
        self.game_over = False
        self.moving = False
        self.remaining = self.time_limit
        self.timer_label.config(text=f"‚è±Ô∏è –í—Ä–µ–º—è: -- —Å")
        self.generate_maze()
        self.draw_maze()
        self.draw_player()
        self.canvas.delete("trail")

    def generate_maze(self):
        self.maze = [[True for _ in range(self.cols)] for _ in range(self.rows)]

        def dfs(x, y):
            self.maze[y][x] = False
            directions = [(0, -2), (0, 2), (-2, 0), (2, 0)]
            random.shuffle(directions)
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 < nx < self.cols - 1 and 0 < ny < self.rows - 1 and self.maze[ny][nx]:
                    self.maze[y + dy // 2][x + dx // 2] = False
                    dfs(nx, ny)

        dfs(1, 1)

        passages = []
        for y in range(1, self.rows - 1):
            for x in range(1, self.cols - 1):
                if not self.maze[y][x]:
                    passages.append((x, y))

        if len(passages) >= self.num_exits + 1:

            self.player_pos = random.choice(passages)
            available_exits = [p for p in passages if p != self.player_pos]
            self.exit_pos = random.sample(available_exits,
                                          min(self.num_exits, len(available_exits)))
        else:
            self.player_pos = (1, 1)
            all_possible = [(self.cols - 2, self.rows - 2),
                            (self.cols - 2, 1),
                            (1, self.rows - 2),
                            (self.cols // 2, 1),
                            (1, self.rows // 2)]
            self.exit_pos = all_possible[:min(self.num_exits, len(all_possible))]

    def draw_maze(self):
        self.canvas.delete("all")
        for y in range(self.rows):
            for x in range(self.cols):
                cx, cy = x * self.cell_size, y * self.cell_size
                if self.maze[y][x]:
                    self.canvas.create_rectangle(
                        cx, cy, cx + self.cell_size, cy + self.cell_size,
                        fill="#2c3e50", outline="#34495e", width=1
                    )

        exit_colors = ["#ff6b6b", "#3498db", "#2ecc71", "#f39c12",
                       "#9b59b6", "#1abc9c", "#e67e22", "#e74c3c",
                       "#34495e", "#7f8c8d"]

        for i, (ex, ey) in enumerate(self.exit_pos):
            cx = ex * self.cell_size + self.cell_size // 2
            cy = ey * self.cell_size + self.cell_size // 2

            color = exit_colors[i % len(exit_colors)]

            # –†–∏—Å—É–µ–º –≤—ã—Ö–æ–¥
            self.canvas.create_rectangle(
                ex * self.cell_size + 2, ey * self.cell_size + 2,
                (ex + 1) * self.cell_size - 2, (ey + 1) * self.cell_size - 2,
                fill=color, outline="white", width=2
            )

            if self.num_exits <= 5:
                self.canvas.create_text(cx, cy, text=f"{i + 1}",
                                        fill="white", font=("Arial", 10, "bold"))
            else:
                pass

    def draw_player(self):
        if hasattr(self, '_player_id'):
            self.canvas.delete(self._player_id)
        x, y = self.player_pos
        cx = x * self.cell_size + self.cell_size // 2
        cy = y * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.35
        self._player_id = self.canvas.create_oval(
            cx - r, cy - r, cx + r, cy + r,
            fill="black", outline="#f1c40f", width=2
        )
        eye_r = r * 0.3
        self.canvas.create_oval(cx - eye_r, cy - eye_r,
                                cx - eye_r / 2, cy - eye_r / 2, fill="white")
        self.canvas.create_oval(cx + eye_r / 2, cy - eye_r,
                                cx + eye_r, cy - eye_r / 2, fill="white")

    def tick_timer(self):
        if not self.game_over:
            self.remaining = max(0, self.remaining - 1)
            color = "#e74c3c" if self.remaining < 10 else "#2c3e50"
            self.timer_label.config(text=f"‚è±Ô∏è –í—Ä–µ–º—è: {self.remaining:02d} —Å", fg=color)
            if self.remaining == 0:
                self.end_game(win=False)
        if not self.game_over:
            self.root.after(1000, self.tick_timer)

    def end_game(self, win):
        self.game_over = True
        self.moving = False
        if win:
            self.timer_label.config(fg="#27ae60")
            exit_num = self.exit_pos.index(self.player_pos) + 1
            colors = ["–∫—Ä–∞—Å–Ω–æ–º—É", "—Å–∏–Ω–µ–º—É", "–∑–µ–ª–µ–Ω–æ–º—É", "–æ—Ä–∞–Ω–∂–µ–≤–æ–º—É",
                      "—Ñ–∏–æ–ª–µ—Ç–æ–≤–æ–º—É", "–±–∏—Ä—é–∑–æ–≤–æ–º—É", "—Ä—ã–∂–µ–º—É", "–±–æ—Ä–¥–æ–≤–æ–º—É",
                      "—Ç–µ–º–Ω–æ-—Å–∏–Ω–µ–º—É", "—Å–µ—Ä–æ–º—É"]
            color_name = colors[min(exit_num - 1, len(colors) - 1)]

            msg = f"üéâ –ü–∞—É–∫ –≤—ã–±—Ä–∞–ª—Å—è –∫ {color_name} –≤—ã—Ö–æ–¥—É ({exit_num})!"
        else:
            msg = f"üò¢ –ü–∞—É–∫ –Ω–µ —É—Å–ø–µ–ª –Ω–∞–π—Ç–∏ –Ω–∏ –æ–¥–∏–Ω –∏–∑ {self.num_exits} –≤—ã—Ö–æ–¥–æ–≤(("

        exit_info = f"–í—Å–µ–≥–æ –≤—ã—Ö–æ–¥–æ–≤: {self.num_exits}, –Ω–∞–π–¥–µ–Ω–æ: {'1' if win else '0'}"
        messagebox.showinfo("üéä –ü–æ–±–µ–¥–∞!" if win else "üíî –ü—Ä–æ–∏–≥—Ä—ã—à",
                            f"{msg}\n\n{exit_info}")

    def start_dfs(self):
        if self.moving or self.game_over:
            return
        self.moving = True
        self.tick_timer()
        self.stack = [self.player_pos]
        self.visited = {self.player_pos}
        self.dfs_step()

    def dfs_step(self):
        if self.game_over or not self.moving:
            return
        if not self.stack:
            return

        current = self.stack[-1]
        self.player_pos = current
        self.draw_player()

        x, y = current
        cx = x * self.cell_size + self.cell_size // 2
        cy = y * self.cell_size + self.cell_size // 2
        r = self.cell_size * 0.12
        self.canvas.create_oval(
            cx - r, cy - r, cx + r, cy + r,
            fill="#f39c12", outline="", tags="trail"
        )

        if current in self.exit_pos:
            self.end_game(win=True)
            return

        neighbors = []
        for dx, dy in [(0, -1), (1, 0), (0, 1), (-1, 0)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < self.cols and 0 <= ny < self.rows:
                if not self.maze[ny][nx] and (nx, ny) not in self.visited:
                    neighbors.append((nx, ny))

        if neighbors:
            next_cell = random.choice(neighbors)
            self.visited.add(next_cell)
            self.stack.append(next_cell)
        else:
            self.stack.pop()

        self.root.after(200, self.dfs_step)


if __name__ == "__main__":
    root = tk.Tk()
    game = MazeGame(root, cols=21, rows=15, cell_size=30,
                    time_limit_sec=40, num_exits=3)
    root.mainloop()
